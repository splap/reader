#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$ROOT_DIR"

# Parse arguments
CLEAN_DATA=0
SCREENSHOT_MODE=0
SCREENSHOT_BOOK=""
SCREENSHOT_CHAPTER=""
SCREENSHOT_CFI=""
SCREENSHOT_OUTPUT=""
SCREENSHOT_RENDERER=""
SCREENSHOT_FONT_SCALE=""
TARGET_DEVICE=""
OPEN_BOOK=""
OPEN_CHAT=0

for arg in "$@"; do
  case "$arg" in
    --clean)
      CLEAN_DATA=1
      ;;
    --screenshot)
      SCREENSHOT_MODE=1
      ;;
    --book=*)
      OPEN_BOOK="${arg#--book=}"
      SCREENSHOT_BOOK="$OPEN_BOOK"  # Also set for screenshot mode compatibility
      ;;
    --chat)
      OPEN_CHAT=1
      ;;
    --chapter=*)
      SCREENSHOT_CHAPTER="${arg#--chapter=}"
      ;;
    --cfi=*)
      SCREENSHOT_CFI="${arg#--cfi=}"
      ;;
    --output=*)
      SCREENSHOT_OUTPUT="${arg#--output=}"
      ;;
    --renderer=*)
      SCREENSHOT_RENDERER="${arg#--renderer=}"
      ;;
    --font-scale=*)
      SCREENSHOT_FONT_SCALE="${arg#--font-scale=}"
      ;;
    --device=*)
      TARGET_DEVICE="${arg#--device=}"
      ;;
  esac
done

# Load local environment from .env if it exists
if [ -f "$ROOT_DIR/.env" ]; then
  set -a
  source "$ROOT_DIR/.env"
  set +a
fi

# If --device is specified, use physical device. Otherwise use simulator.
if [ -n "$TARGET_DEVICE" ]; then
  USE_SIMULATOR=0
else
  USE_SIMULATOR="${USE_SIMULATOR:-1}"
fi

# Device builds require DEVELOPMENT_TEAM for code signing
if [ "$USE_SIMULATOR" = "0" ] && [ -z "${DEVELOPMENT_TEAM:-}" ]; then
  echo "Error: Device builds require DEVELOPMENT_TEAM in .env" >&2
  echo "  1. Copy .env.example to .env if you haven't" >&2
  echo "  2. Set DEVELOPMENT_TEAM to your Apple Team ID" >&2
  echo "  3. Run ./scripts/bootstrap to regenerate the project" >&2
  exit 1
fi

if [ "$USE_SIMULATOR" = "1" ]; then
  echo "Running on simulator..."
  DEVICE_NAME="iPad Pro 11-inch (M5)"
  APP_BUNDLE_ID="com.splap.reader"
  SDK="iphonesimulator"

  # Check claim ticket first - don't steal another agent's simulator
  CLAIM_FILE="$ROOT_DIR/simulator-uuid"
  if [ -f "$CLAIM_FILE" ]; then
    DEVICE_UDID=$(cat "$CLAIM_FILE")
    STATE=$(xcrun simctl list devices -j | jq -r --arg udid "$DEVICE_UDID" \
      '.devices | to_entries[] | .value[] | select(.udid == $udid) | .state' | head -1)
    [ -z "$STATE" ] && STATE="NotFound"

    if [ "$STATE" = "Booted" ]; then
      echo "Using our simulator: $DEVICE_UDID"
    elif [ "$STATE" = "Shutdown" ]; then
      echo "Booting our simulator: $DEVICE_UDID"
      xcrun simctl boot "$DEVICE_UDID" || true
      xcrun simctl bootstatus "$DEVICE_UDID" -b
    else
      echo "Claimed simulator $DEVICE_UDID not found, rm simulator-uuid and re run to create a new one."
    fi
  fi

  # If no valid claim, boot a new (non-booted) simulator
  if [ ! -f "$CLAIM_FILE" ]; then
    DEVICE_UDID=$(xcrun simctl list devices available -j | jq -r '
      .devices | to_entries[] |
      select(.key | test("iOS-26|iOS-18-2")) |
      .value[] |
      select(.name == "iPad Pro 11-inch (M5)" and .state == "Shutdown") |
      .udid' | head -1)

    if [ -z "$DEVICE_UDID" ]; then
      echo "No available (shutdown) simulator for $DEVICE_NAME. All may be in use."
      WORKSPACE_NAME="$(basename "$ROOT_DIR")"
      printf "Create a new simulator named '%s'? [y/N] " "$WORKSPACE_NAME"
      read -r REPLY
      if [[ "$REPLY" =~ ^[Yy]$ ]]; then
        RUNTIME=$(xcrun simctl list runtimes available -j | jq -r '
          .runtimes[] | select(.name | test("iOS")) | .identifier' | sort -rV | head -1)
        if [ -z "$RUNTIME" ]; then
          echo "No iOS runtime found." >&2
          exit 1
        fi
        echo "Creating simulator '$WORKSPACE_NAME' with runtime $RUNTIME..."
        DEVICE_UDID=$(xcrun simctl create "$WORKSPACE_NAME" "$DEVICE_NAME" "$RUNTIME")
        echo "Created simulator: $DEVICE_UDID"
      else
        echo "Aborted." >&2
        exit 1
      fi
    fi

    echo "Booting new simulator: $DEVICE_UDID"
    xcrun simctl boot "$DEVICE_UDID" || true
    xcrun simctl bootstatus "$DEVICE_UDID" -b
    echo "$DEVICE_UDID" > "$CLAIM_FILE"
  fi
else
  echo "Running on physical iPad..."
  # Find iOS device using JSON for reliable UDID extraction
  DEVICES_JSON=$(mktemp)
  xcrun devicectl list devices -j "$DEVICES_JSON" 2>/dev/null

  if [ -n "$TARGET_DEVICE" ]; then
    # Find device by name (case-insensitive partial match)
    MATCHING_DEVICES=$(jq -r --arg name "$TARGET_DEVICE" '
      [.result.devices[] |
       select(.deviceProperties.name | ascii_downcase | contains($name | ascii_downcase)) |
       .deviceProperties.name] | .[]
    ' "$DEVICES_JSON")
    MATCH_COUNT=$(echo "$MATCHING_DEVICES" | grep -c . || true)

    if [ "$MATCH_COUNT" -gt 1 ]; then
      echo "Ambiguous device name '$TARGET_DEVICE' matches $MATCH_COUNT devices:" >&2
      echo "$MATCHING_DEVICES" | sed 's/^/  /' >&2
      rm -f "$DEVICES_JSON"
      exit 1
    fi

    DEVICE_UDID=$(jq -r --arg name "$TARGET_DEVICE" '
      .result.devices[] |
      select(.deviceProperties.name | ascii_downcase | contains($name | ascii_downcase)) |
      .hardwareProperties.udid
    ' "$DEVICES_JSON" | head -1)
    DEVICE_NAME=$(jq -r --arg name "$TARGET_DEVICE" '
      .result.devices[] |
      select(.deviceProperties.name | ascii_downcase | contains($name | ascii_downcase)) |
      .deviceProperties.name
    ' "$DEVICES_JSON" | head -1)
  else
    # Use first connected device
    DEVICE_UDID=$(jq -r '
      .result.devices[] |
      select(.connectionProperties.tunnelState == "connected") |
      .hardwareProperties.udid
    ' "$DEVICES_JSON" | head -1)
    DEVICE_NAME=$(jq -r '
      .result.devices[] |
      select(.connectionProperties.tunnelState == "connected") |
      .deviceProperties.name
    ' "$DEVICES_JSON" | head -1)
  fi
  rm -f "$DEVICES_JSON"

  if [ -z "$DEVICE_UDID" ]; then
    if [ -n "$TARGET_DEVICE" ]; then
      echo "No device matching '$TARGET_DEVICE' found." >&2
    else
      echo "No connected physical device found." >&2
    fi
    echo "Available devices:" >&2
    xcrun devicectl list devices 2>/dev/null | grep -E "iPad|iPhone" >&2
    exit 1
  fi
  echo "Using device: $DEVICE_NAME ($DEVICE_UDID)"
  APP_BUNDLE_ID="com.splap.reader"
  SDK="iphoneos"
fi

# Clean app data if requested
if [ "$CLEAN_DATA" = "1" ]; then
  if [ "$USE_SIMULATOR" = "1" ]; then
    echo "Cleaning app data from simulator..."
    APP_CONTAINER=$(xcrun simctl get_app_container "$DEVICE_UDID" "$APP_BUNDLE_ID" data 2>/dev/null || true)
    if [ -n "$APP_CONTAINER" ]; then
      # Clear Application Support (page layouts, vector indices, chunk store, etc.)
      SUPPORT_DIR="$APP_CONTAINER/Library/Application Support/com.splap.reader"
      if [ -d "$SUPPORT_DIR" ]; then
        echo "  Removing: $SUPPORT_DIR"
        rm -rf "$SUPPORT_DIR"
      fi
      # Clear Documents (any cached content)
      DOCS_DIR="$APP_CONTAINER/Documents"
      if [ -d "$DOCS_DIR" ]; then
        echo "  Clearing Documents folder..."
        rm -rf "$DOCS_DIR"/*
      fi
      echo "App data cleaned."
    else
      echo "No app container found (app not installed yet)"
    fi
  else
    echo "Warning: --clean only supported for simulator"
  fi
fi

# Ensure embedding model exists (required for semantic search)
ML_MODEL_PATH="$ROOT_DIR/App/Resources/bge-small-en.mlpackage"
if [ ! -d "$ML_MODEL_PATH" ]; then
  echo "Embedding model missing. Generating..."
  uv run --with "transformers<5" --with "torch>=2.7,<2.8" --with coremltools --with "numpy<2" --with scipy \
    python "$ROOT_DIR/scripts/convert_bge_to_coreml.py"
fi

# Build the app
echo "Building for $SDK..."
if [ "$USE_SIMULATOR" = "1" ]; then
  PLATFORM="iOS Simulator"
else
  PLATFORM="iOS"
fi

DERIVED_DATA="$ROOT_DIR/.build/DerivedData"

xcodebuild \
  -scheme ReaderApp \
  -destination "platform=$PLATFORM,id=$DEVICE_UDID" \
  -derivedDataPath "$DERIVED_DATA" \
  -allowProvisioningUpdates \
  -quiet \
  build

APP_PATH="$DERIVED_DATA/Build/Products/Debug-$SDK/ReaderApp.app"

if [ ! -d "$APP_PATH" ]; then
  echo "App not found at $APP_PATH. Build failed?" >&2
  exit 1
fi

echo "Installing app..."
if [ "$USE_SIMULATOR" = "1" ]; then
  # Uninstall first to prevent orphaned containers accumulating
  # Each install creates a new container; old ones are never cleaned up
  # and their CoreML caches (128MB each) pile up fast
  xcrun simctl uninstall "$DEVICE_UDID" "$APP_BUNDLE_ID" 2>/dev/null || true
  xcrun simctl install "$DEVICE_UDID" "$APP_PATH"

  # Load test books if available (set TEST_BOOKS_DIR in .env or environment)
  BOOKS_SOURCE="${TEST_BOOKS_DIR:-}"
  if [ -n "$BOOKS_SOURCE" ] && [ -d "$BOOKS_SOURCE" ]; then
    echo "Loading test books..."
    APP_CONTAINER=$(xcrun simctl get_app_container "$DEVICE_UDID" "$APP_BUNDLE_ID" data 2>/dev/null || true)
    if [ -n "$APP_CONTAINER" ]; then
      BOOKS_DIR="$APP_CONTAINER/Documents/TestBooks"
      mkdir -p "$BOOKS_DIR"
      cp "$BOOKS_SOURCE"/*.epub "$BOOKS_DIR/" 2>/dev/null || true
      BOOK_COUNT=$(ls "$BOOKS_DIR"/*.epub 2>/dev/null | wc -l | xargs)
      echo "Loaded $BOOK_COUNT test book(s)"
    fi
  fi

  # Deploy OpenRouter API key to simulator UserDefaults (survives app reinstall)
  if [ -n "${OPENROUTER_API_KEY:-}" ]; then
    echo "Deploying OpenRouter API key..."
    xcrun simctl spawn "$DEVICE_UDID" defaults write "$APP_BUNDLE_ID" OpenRouterAPIKey "$OPENROUTER_API_KEY"
  fi
else
  xcrun devicectl device install app --device "$DEVICE_UDID" "$APP_PATH" 2>&1 | grep -v "acquired" || true
fi

echo "Launching app..."
if [ "$USE_SIMULATOR" = "1" ]; then
  # Screenshot mode - special headless launch
  if [ "$SCREENSHOT_MODE" = "1" ]; then
    if [ -z "$SCREENSHOT_BOOK" ]; then
      echo "Error: --book= is required for screenshot mode" >&2
      exit 1
    fi
    if [ -z "$SCREENSHOT_OUTPUT" ]; then
      echo "Error: --output= is required for screenshot mode" >&2
      exit 1
    fi

    # Build app arguments
    APP_ARGS="--screenshot-mode --screenshot-book=$SCREENSHOT_BOOK --screenshot-output=$SCREENSHOT_OUTPUT"
    if [ -n "$SCREENSHOT_CHAPTER" ]; then
      APP_ARGS="$APP_ARGS --screenshot-chapter=$SCREENSHOT_CHAPTER"
    fi
    if [ -n "$SCREENSHOT_CFI" ]; then
      APP_ARGS="$APP_ARGS --screenshot-cfi=$SCREENSHOT_CFI"
    fi
    if [ -n "$SCREENSHOT_RENDERER" ]; then
      APP_ARGS="$APP_ARGS --screenshot-renderer=$SCREENSHOT_RENDERER"
    fi
    if [ -n "$SCREENSHOT_FONT_SCALE" ]; then
      APP_ARGS="$APP_ARGS --screenshot-font-scale=$SCREENSHOT_FONT_SCALE"
    fi

    echo "Screenshot mode: book=$SCREENSHOT_BOOK output=$SCREENSHOT_OUTPUT"

    # Terminate any existing instance
    xcrun simctl terminate "$DEVICE_UDID" "$APP_BUNDLE_ID" 2>/dev/null || true

    # Launch with --console-pty to wait for app exit
    # shellcheck disable=SC2086
    xcrun simctl launch --console-pty "$DEVICE_UDID" "$APP_BUNDLE_ID" $APP_ARGS

    # Verify output file exists
    if [ -f "$SCREENSHOT_OUTPUT" ]; then
      echo "Screenshot saved: $SCREENSHOT_OUTPUT"
      exit 0
    else
      echo "Error: Screenshot file not found at $SCREENSHOT_OUTPUT" >&2
      exit 1
    fi
  fi

  # Normal launch mode - build app arguments
  APP_ARGS=""
  if [ -n "$OPEN_BOOK" ]; then
    APP_ARGS="$APP_ARGS --uitesting-book=$OPEN_BOOK"
  fi
  if [ "$OPEN_CHAT" = "1" ]; then
    APP_ARGS="$APP_ARGS --open-chat"
  fi

  if [ -n "$APP_ARGS" ]; then
    echo "Launch args: $APP_ARGS"
    # shellcheck disable=SC2086
    xcrun simctl launch "$DEVICE_UDID" "$APP_BUNDLE_ID" $APP_ARGS
  else
    xcrun simctl launch "$DEVICE_UDID" "$APP_BUNDLE_ID"
  fi
  echo ""
  echo "=== App Logs (com.splap.reader) ==="
  echo "Press Ctrl+C to stop"
  echo ""
  xcrun simctl spawn "$DEVICE_UDID" log stream --style compact --level debug --predicate 'subsystem == "com.splap.reader"' 2>/dev/null
else
  xcrun devicectl device process launch --device "$DEVICE_UDID" "$APP_BUNDLE_ID"

  echo ""
  echo "=== App Logs (com.splap.reader) ==="
  echo "Press Ctrl+C to stop"
  echo ""

  if command -v idevicesyslog >/dev/null 2>&1; then
    # Filter to our app process, then grep for our Logger output only
    # Our logs appear as ReaderApp(ReaderApp.debug.dylib) or ReaderApp(ReaderApp.dylib)
    idevicesyslog -u "$DEVICE_UDID" -p ReaderApp 2>/dev/null \
      | grep --line-buffered -E "ReaderApp\.(debug\.)?dylib"
  else
    echo "Install libimobiledevice for device logs: brew install libimobiledevice"
    echo "App launched. Logs not available without idevicesyslog."
  fi
fi
