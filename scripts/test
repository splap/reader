#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
cd "$ROOT_DIR"

PROJECT="Reader.xcodeproj"
CONFIGURATION="Debug"
DERIVED_DATA="$ROOT_DIR/.build/DerivedData"

# Use simulator-uuid if available, otherwise fall back to name-based destination
if [ -f "$ROOT_DIR/simulator-uuid" ]; then
  UDID=$(cat "$ROOT_DIR/simulator-uuid")
  DESTINATION="platform=iOS Simulator,id=$UDID"
else
  DESTINATION="platform=iOS Simulator,name=iPad Pro 11-inch (M5),OS=26.0.1,arch=arm64"
fi
EXTRA_BUILD_SETTINGS=""

# Parse test type argument: unit (default), ui, all, or perf
TEST_TYPE="${1:-unit}"

if [ "${UPDATE_SNAPSHOTS:-}" = "1" ]; then
  EXTRA_BUILD_SETTINGS="SWIFT_ACTIVE_COMPILATION_CONDITIONS=DEBUG SNAPSHOT_RECORD"
fi

if [ ! -d "$PROJECT" ]; then
  echo "$PROJECT not found. Run ./scripts/bootstrap first." >&2
  exit 1
fi

run_tests() {
  local scheme="$1"
  local test_filter="${2:-}"
  echo "Running tests for scheme: $scheme"

  local xcodebuild_args=(
    -project "$PROJECT"
    -scheme "$scheme"
    -configuration "$CONFIGURATION"
    -destination "$DESTINATION"
    -derivedDataPath "$DERIVED_DATA"
  )

  if [ -n "$EXTRA_BUILD_SETTINGS" ]; then
    xcodebuild_args+=("$EXTRA_BUILD_SETTINGS")
  fi

  if [ -n "$test_filter" ]; then
    xcodebuild_args+=(-only-testing:"$test_filter")
  fi

  # Write test configuration to temp file for UI tests to read
  if [ -n "${BOOK:-}" ] || [ -n "${CHAPTER:-}" ] || [ -n "${PAGE:-}" ] || [ -n "${CHAPTER_COUNT:-}" ]; then
    mkdir -p /tmp/reader-tests
    cat > /tmp/reader-tests/test-config.json << EOF
{
  "book": "${BOOK:-frankenstein}",
  "chapter": "${CHAPTER:-0}",
  "page": "${PAGE:-1}",
  "chapterCount": "${CHAPTER_COUNT:-5}"
}
EOF
  fi

  xcodebuild_args+=(test)

  xcodebuild "${xcodebuild_args[@]}"
}

case "$TEST_TYPE" in
  unit)
    run_tests "ReaderApp"
    ;;
  ui)
    run_tests "ReaderAppUITests"
    ;;
  all)
    run_tests "ReaderApp"
    echo ""
    run_tests "ReaderAppUITests"
    ;;
  help|-h|--help)
    echo "Usage: $0 [unit|ui|all|--list|<test-pattern>|ui:<test-pattern>]" >&2
    echo "  unit (default): Run unit and snapshot tests" >&2
    echo "  ui: Run UI tests only" >&2
    echo "  all: Run all tests" >&2
    echo "  --list: List all available tests" >&2
    echo "  <test-pattern>: Run matching unit test (e.g., testPositionStoreRoundTrip, VectorStoreTests)" >&2
    echo "  ui:<test-pattern>: Run matching UI test (e.g., ui:testScrubberAppearsOnTap)" >&2
    exit 0
    ;;
  --list|list)
    # List tests organized by source file
    # This leverages the file structure - new tests automatically appear in the right place

    list_tests_by_file() {
      local dir="$1"
      local prefix="${2:-}"  # e.g., "ui:" for UI tests

      for file in "$dir"/*.swift; do
        [ -f "$file" ] || continue

        # Skip helper files (no test methods)
        local tests
        tests=$(grep -o "func test[A-Za-z0-9_]*" "$file" 2>/dev/null | sed 's/func //' | sort || true)
        [ -z "$tests" ] && continue

        # Extract category from filename (e.g., "PaginationTests.swift" -> "Pagination")
        local basename
        basename=$(basename "$file" .swift)
        local category="${basename%Tests}"  # Remove "Tests" suffix if present
        category="${category%UITests}"      # Remove "UITests" suffix if present

        echo "  $category:"
        echo "$tests" | while read -r test; do
          echo "    $prefix$test"
        done
      done
    }

    echo "Unit tests:"
    echo ""

    # ReaderCore tests (main unit tests)
    if [ -d "$ROOT_DIR/Packages/ReaderKit/Tests/ReaderCoreTests" ]; then
      list_tests_by_file "$ROOT_DIR/Packages/ReaderKit/Tests/ReaderCoreTests"
    fi

    # Snapshot tests
    if [ -d "$ROOT_DIR/Packages/ReaderKit/Tests/ReaderUITests" ]; then
      echo ""
      echo "  Snapshots:"
      for file in "$ROOT_DIR/Packages/ReaderKit/Tests/ReaderUITests"/*.swift; do
        [ -f "$file" ] || continue
        grep -o "func test[A-Za-z0-9_]*" "$file" 2>/dev/null | sed 's/func /    /' | sort || true
      done
    fi

    echo ""
    echo "UI tests (use ui: prefix):"
    echo ""
    list_tests_by_file "$ROOT_DIR/App/UITests" "ui:"

    exit 0
    ;;
  ui:*)
    # UI test with prefix syntax: ui:testFoo
    TEST_NAME="${TEST_TYPE#ui:}"

    # Search for the test in all UI test files to find the correct class
    UI_TEST_CLASS=""
    for file in "$ROOT_DIR/App/UITests"/*.swift; do
      if grep -q "func $TEST_NAME" "$file" 2>/dev/null; then
        UI_TEST_CLASS=$(grep -o "class [A-Za-z0-9_]*" "$file" | head -1 | cut -d' ' -f2)
        break
      fi
    done

    if [ -z "$UI_TEST_CLASS" ]; then
      echo "Error: Could not find UI test '$TEST_NAME' in App/UITests/" >&2
      exit 1
    fi

    run_tests "ReaderAppUITests" "ReaderAppUITests/$UI_TEST_CLASS/$TEST_NAME"
    ;;
  *)
    # Default: treat as unit test pattern
    # Search for matching test in unit test directories
    PATTERN="$TEST_TYPE"

    # Check if it looks like a UI test
    if grep -rq "func $PATTERN\|class $PATTERN" "$ROOT_DIR/App/UITests" 2>/dev/null; then
      echo "Note: '$PATTERN' looks like a UI test. Use 'ui:$PATTERN' to run it." >&2
      exit 1
    fi

    # Search unit test directories for the pattern
    UNIT_TEST_DIRS=(
      "Packages/ReaderKit/Tests/ReaderCoreTests:ReaderCoreUnitTests"
      "Packages/ReaderKit/Tests/ReaderUITests:ReaderUISnapshotTests"
      "App/Tests:ReaderAppTests"
    )

    FOUND_BUNDLE=""
    FOUND_CLASS=""

    for entry in "${UNIT_TEST_DIRS[@]}"; do
      DIR="${entry%:*}"
      BUNDLE="${entry#*:}"

      # Look for test method: func testFoo
      MATCH=$(grep -rl "func $PATTERN" "$ROOT_DIR/$DIR" 2>/dev/null | head -1 || true)
      if [ -n "$MATCH" ]; then
        FOUND_BUNDLE="$BUNDLE"
        # Find line number of test, then find the class it belongs to
        TEST_LINE=$(grep -n "func $PATTERN" "$MATCH" | head -1 | cut -d: -f1)
        # Find the most recent class declaration before this line
        FOUND_CLASS=$(head -n "$TEST_LINE" "$MATCH" | grep -o "class [A-Za-z0-9_]*" | tail -1 | cut -d' ' -f2)
        break
      fi

      # Look for test class: class FooTests
      MATCH=$(grep -rl "class $PATTERN" "$ROOT_DIR/$DIR" 2>/dev/null | head -1 || true)
      if [ -n "$MATCH" ]; then
        FOUND_BUNDLE="$BUNDLE"
        FOUND_CLASS="$PATTERN"
        PATTERN=""  # Running whole class, not a specific test
        break
      fi
    done

    if [ -z "$FOUND_BUNDLE" ]; then
      echo "Error: Could not find test matching '$TEST_TYPE'" >&2
      echo "Searched in: ReaderCoreTests, ReaderUITests, AppTests" >&2
      exit 1
    fi

    if [ -n "$PATTERN" ]; then
      # Specific test method
      TEST_FILTER="$FOUND_BUNDLE/$FOUND_CLASS/$PATTERN"
    else
      # Whole test class
      TEST_FILTER="$FOUND_BUNDLE/$FOUND_CLASS"
    fi

    echo "Found: $TEST_FILTER"
    run_tests "ReaderApp" "$TEST_FILTER"
    ;;
esac
